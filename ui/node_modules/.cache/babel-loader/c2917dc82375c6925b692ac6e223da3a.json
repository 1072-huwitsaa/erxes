{"ast":null,"code":"var DEBUG = false; // `true` to print debugging info.\n\nvar TIMER = false; // `true` to time calls to `lex()` and print the results.\n\nvar debug = require('./debug')('lex');\n\nexports = module.exports = lex;\n/**\r\n * Convert a CSS string into an array of lexical tokens.\r\n *\r\n * @param {String} css CSS\r\n * @returns {Array} lexical tokens\r\n */\n\nfunction lex(css) {\n  var start; // Debug timer start.\n\n  var buffer = ''; // Character accumulator\n\n  var ch; // Current character\n\n  var column = 0; // Current source column number\n\n  var cursor = -1; // Current source cursor position\n\n  var depth = 0; // Current nesting depth\n\n  var line = 1; // Current source line number\n\n  var state = 'before-selector'; // Current state\n\n  var stack = [state]; // State stack\n\n  var token = {}; // Current token\n\n  var tokens = []; // Token accumulator\n  // Supported @-rules, in roughly descending order of usage probability.\n\n  var atRules = ['media', 'keyframes', {\n    name: '-webkit-keyframes',\n    type: 'keyframes',\n    prefix: '-webkit-'\n  }, {\n    name: '-moz-keyframes',\n    type: 'keyframes',\n    prefix: '-moz-'\n  }, {\n    name: '-ms-keyframes',\n    type: 'keyframes',\n    prefix: '-ms-'\n  }, {\n    name: '-o-keyframes',\n    type: 'keyframes',\n    prefix: '-o-'\n  }, 'font-face', {\n    name: 'import',\n    state: 'before-at-value'\n  }, {\n    name: 'charset',\n    state: 'before-at-value'\n  }, 'supports', 'viewport', {\n    name: 'namespace',\n    state: 'before-at-value'\n  }, 'document', {\n    name: '-moz-document',\n    type: 'document',\n    prefix: '-moz-'\n  }, 'page']; // -- Functions ------------------------------------------------------------\n\n  /**\r\n   * Advance the character cursor and return the next character.\r\n   *\r\n   * @returns {String} The next character.\r\n   */\n\n  function getCh() {\n    skip();\n    return css[cursor];\n  }\n  /**\r\n   * Return the state at the given index in the stack.\r\n   * The stack is LIFO so indexing is from the right.\r\n   *\r\n   * @param {Number} [index=0] Index to return.\r\n   * @returns {String} state\r\n   */\n\n\n  function getState(index) {\n    return index ? stack[stack.length - 1 - index] : state;\n  }\n  /**\r\n   * Look ahead for a string beginning from the next position. The string\r\n   * being looked for must start at the next position.\r\n   *\r\n   * @param {String} str The string to look for.\r\n   * @returns {Boolean} Whether the string was found.\r\n   */\n\n\n  function isNextString(str) {\n    var start = cursor + 1;\n    return str === css.slice(start, start + str.length);\n  }\n  /**\r\n   * Find the start position of a substring beginning from the next\r\n   * position. The string being looked for may begin anywhere.\r\n   *\r\n   * @param {String} str The substring to look for.\r\n   * @returns {Number|false} The position, or `false` if not found.\r\n   */\n\n\n  function find(str) {\n    var pos = css.slice(cursor).indexOf(str);\n    return pos > 0 ? pos : false;\n  }\n  /**\r\n   * Determine whether a character is next.\r\n   *\r\n   * @param {String} ch Character.\r\n   * @returns {Boolean} Whether the character is next.\r\n   */\n\n\n  function isNextChar(ch) {\n    return ch === peek(1);\n  }\n  /**\r\n   * Return the character at the given cursor offset. The offset is relative\r\n   * to the cursor, so negative values move backwards.\r\n   *\r\n   * @param {Number} [offset=1] Cursor offset.\r\n   * @returns {String} Character.\r\n   */\n\n\n  function peek(offset) {\n    return css[cursor + (offset || 1)];\n  }\n  /**\r\n   * Remove the current state from the stack and set the new current state.\r\n   *\r\n   * @returns {String} The removed state.\r\n   */\n\n\n  function popState() {\n    var removed = stack.pop();\n    state = stack[stack.length - 1];\n    return removed;\n  }\n  /**\r\n   * Set the current state and add it to the stack.\r\n   *\r\n   * @param {String} newState The new state.\r\n   * @returns {Number} The new stack length.\r\n   */\n\n\n  function pushState(newState) {\n    state = newState;\n    stack.push(state);\n    return stack.length;\n  }\n  /**\r\n   * Replace the current state with a new state.\r\n   *\r\n   * @param {String} newState The new state.\r\n   * @returns {String} The replaced state.\r\n   */\n\n\n  function replaceState(newState) {\n    var previousState = state;\n    stack[stack.length - 1] = state = newState;\n    return previousState;\n  }\n  /**\r\n   * Move the character cursor. Positive numbers move the cursor forward.\r\n   * Negative numbers are not supported!\r\n   *\r\n   * @param {Number} [n=1] Number of characters to skip.\r\n   */\n\n\n  function skip(n) {\n    if ((n || 1) == 1) {\n      if (css[cursor] == '\\n') {\n        line++;\n        column = 1;\n      } else {\n        column++;\n      }\n\n      cursor++;\n    } else {\n      var skipStr = css.slice(cursor, cursor + n).split('\\n');\n\n      if (skipStr.length > 1) {\n        line += skipStr.length - 1;\n        column = 1;\n      }\n\n      column += skipStr[skipStr.length - 1].length;\n      cursor = cursor + n;\n    }\n  }\n  /**\r\n   * Add the current token to the pile and reset the buffer.\r\n   */\n\n\n  function addToken() {\n    token.end = {\n      line: line,\n      col: column\n    };\n    DEBUG && debug('addToken:', JSON.stringify(token, null, 2));\n    tokens.push(token);\n    buffer = '';\n    token = {};\n  }\n  /**\r\n   * Set the current token.\r\n   *\r\n   * @param {String} type Token type.\r\n   */\n\n\n  function initializeToken(type) {\n    token = {\n      type: type,\n      start: {\n        line: line,\n        col: column\n      }\n    };\n  } // -- Main Loop ------------------------------------------------------------\n\n  /*\r\n  The main loop is a state machine that reads in one character at a time,\r\n  and determines what to do based on the current state and character.\r\n  This is implemented as a series of nested `switch` statements and the\r\n  case orders have been mildly optimized based on rough probabilities\r\n  calculated by processing a small sample of real-world CSS.\r\n    Further optimization (such as a dispatch table) shouldn't be necessary\r\n  since the total number of cases is very low.\r\n  */\n\n\n  TIMER && (start = Date.now());\n\n  while (ch = getCh()) {\n    DEBUG && debug(ch, getState()); // column += 1;\n\n    switch (ch) {\n      // Space\n      case ' ':\n        switch (getState()) {\n          case 'selector':\n          case 'value':\n          case 'value-paren':\n          case 'at-group':\n          case 'at-value':\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            buffer += ch;\n            break;\n        }\n\n        break;\n      // Newline or tab\n\n      case '\\n':\n      case '\\t':\n      case '\\r':\n      case '\\f':\n        switch (getState()) {\n          case 'value':\n          case 'value-paren':\n          case 'at-group':\n          case 'comment':\n          case 'single-string':\n          case 'double-string':\n          case 'selector':\n            buffer += ch;\n            break;\n\n          case 'at-value':\n            // Tokenize an @-rule if a semi-colon was omitted.\n            if ('\\n' === ch) {\n              token.value = buffer.trim();\n              addToken();\n              popState();\n            }\n\n            break;\n        } // if ('\\n' === ch) {\n        //   column = 0;\n        //   line += 1;\n        // }\n\n\n        break;\n\n      case ':':\n        switch (getState()) {\n          case 'name':\n            token.name = buffer.trim();\n            buffer = '';\n            replaceState('before-value');\n            break;\n\n          case 'before-selector':\n            buffer += ch;\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case ';':\n        switch (getState()) {\n          case 'name':\n          case 'before-value':\n          case 'value':\n            // Tokenize a declaration\n            // if value is empty skip the declaration\n            if (buffer.trim().length > 0) {\n              token.value = buffer.trim(), addToken();\n            }\n\n            replaceState('before-name');\n            break;\n\n          case 'value-paren':\n            // Insignificant semi-colon\n            buffer += ch;\n            break;\n\n          case 'at-value':\n            // Tokenize an @-rule\n            token.value = buffer.trim();\n            addToken();\n            popState();\n            break;\n\n          case 'before-name':\n            // Extraneous semi-colon\n            break;\n\n          default:\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case '{':\n        switch (getState()) {\n          case 'selector':\n            // If the sequence is `\\{` then assume that the brace should be escaped.\n            if (peek(-1) === '\\\\') {\n              buffer += ch;\n              break;\n            } // Tokenize a selector\n\n\n            token.text = buffer.trim();\n            addToken();\n            replaceState('before-name');\n            depth = depth + 1;\n            break;\n\n          case 'at-group':\n            // Tokenize an @-group\n            token.name = buffer.trim(); // XXX: @-rules are starting to get hairy\n\n            switch (token.type) {\n              case 'font-face':\n              case 'viewport':\n              case 'page':\n                pushState('before-name');\n                break;\n\n              default:\n                pushState('before-selector');\n            }\n\n            addToken();\n            depth = depth + 1;\n            break;\n\n          case 'name':\n          case 'at-rule':\n            // Tokenize a declaration or an @-rule\n            token.name = buffer.trim();\n            addToken();\n            pushState('before-name');\n            depth = depth + 1;\n            break;\n\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            // Ignore braces in comments and strings\n            buffer += ch;\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n        }\n\n        break;\n\n      case '}':\n        switch (getState()) {\n          case 'before-name':\n          case 'name':\n          case 'before-value':\n          case 'value':\n            // If the buffer contains anything, it is a value\n            if (buffer) {\n              token.value = buffer.trim();\n            } // If the current token has a name and a value it should be tokenized.\n\n\n            if (token.name && token.value) {\n              addToken();\n            } // Leave the block\n\n\n            initializeToken('end');\n            addToken();\n            popState(); // We might need to leave again.\n            // XXX: What about 3 levels deep?\n\n            if ('at-group' === getState()) {\n              initializeToken('at-group-end');\n              addToken();\n              popState();\n            }\n\n            if (depth > 0) {\n              depth = depth - 1;\n            }\n\n            break;\n\n          case 'at-group':\n          case 'before-selector':\n          case 'selector':\n            // If the sequence is `\\}` then assume that the brace should be escaped.\n            if (peek(-1) === '\\\\') {\n              buffer += ch;\n              break;\n            }\n\n            if (depth > 0) {\n              // Leave block if in an at-group\n              if ('at-group' === getState(1)) {\n                initializeToken('at-group-end');\n                addToken();\n              }\n            }\n\n            if (depth > 1) {\n              popState();\n            }\n\n            if (depth > 0) {\n              depth = depth - 1;\n            }\n\n            break;\n\n          case 'double-string':\n          case 'single-string':\n          case 'comment':\n            // Ignore braces in comments and strings.\n            buffer += ch;\n            break;\n        }\n\n        break;\n      // Strings\n\n      case '\"':\n      case \"'\":\n        switch (getState()) {\n          case 'double-string':\n            if ('\"' === ch && '\\\\' !== peek(-1)) {\n              popState();\n            }\n\n            break;\n\n          case 'single-string':\n            if (\"'\" === ch && '\\\\' !== peek(-1)) {\n              popState();\n            }\n\n            break;\n\n          case 'before-at-value':\n            replaceState('at-value');\n            pushState('\"' === ch ? 'double-string' : 'single-string');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            pushState('\"' === ch ? 'double-string' : 'single-string');\n            break;\n\n          case 'comment':\n            // Ignore strings within comments.\n            break;\n\n          default:\n            if ('\\\\' !== peek(-1)) {\n              pushState('\"' === ch ? 'double-string' : 'single-string');\n            }\n\n        }\n\n        buffer += ch;\n        break;\n      // Comments\n\n      case '/':\n        switch (getState()) {\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            // Ignore\n            buffer += ch;\n            break;\n\n          case 'before-value':\n          case 'selector':\n          case 'name':\n          case 'value':\n            if (isNextChar('*')) {\n              // Ignore comments in selectors, properties and values. They are\n              // difficult to represent in the AST.\n              var pos = find('*/');\n\n              if (pos) {\n                skip(pos + 1);\n              }\n            } else {\n              if (getState() == 'before-value') replaceState('value');\n              buffer += ch;\n            }\n\n            break;\n\n          default:\n            if (isNextChar('*')) {\n              // Create a comment token\n              initializeToken('comment');\n              pushState('comment');\n              skip();\n            } else {\n              buffer += ch;\n            }\n\n            break;\n        }\n\n        break;\n      // Comment end or universal selector\n\n      case '*':\n        switch (getState()) {\n          case 'comment':\n            if (isNextChar('/')) {\n              // Tokenize a comment\n              token.text = buffer; // Don't trim()!\n\n              skip();\n              addToken();\n              popState();\n            } else {\n              buffer += ch;\n            }\n\n            break;\n\n          case 'before-selector':\n            buffer += ch;\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            buffer += ch;\n        }\n\n        break;\n      // @-rules\n\n      case '@':\n        switch (getState()) {\n          case 'comment':\n          case 'double-string':\n          case 'single-string':\n            buffer += ch;\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            buffer += ch;\n            break;\n\n          default:\n            // Iterate over the supported @-rules and attempt to tokenize one.\n            var tokenized = false;\n            var name;\n            var rule;\n\n            for (var j = 0, len = atRules.length; !tokenized && j < len; ++j) {\n              rule = atRules[j];\n              name = rule.name || rule;\n\n              if (!isNextString(name)) {\n                continue;\n              }\n\n              tokenized = true;\n              initializeToken(name);\n              pushState(rule.state || 'at-group');\n              skip(name.length);\n\n              if (rule.prefix) {\n                token.prefix = rule.prefix;\n              }\n\n              if (rule.type) {\n                token.type = rule.type;\n              }\n            }\n\n            if (!tokenized) {\n              // Keep on truckin' America!\n              buffer += ch;\n            }\n\n            break;\n        }\n\n        break;\n      // Parentheses are tracked to disambiguate semi-colons, such as within a\n      // data URI.\n\n      case '(':\n        switch (getState()) {\n          case 'value':\n            pushState('value-paren');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n\n      case ')':\n        switch (getState()) {\n          case 'value-paren':\n            popState();\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n\n      default:\n        switch (getState()) {\n          case 'before-selector':\n            initializeToken('selector');\n            pushState('selector');\n            break;\n\n          case 'before-name':\n            initializeToken('property');\n            replaceState('name');\n            break;\n\n          case 'before-value':\n            replaceState('value');\n            break;\n\n          case 'before-at-value':\n            replaceState('at-value');\n            break;\n        }\n\n        buffer += ch;\n        break;\n    }\n  }\n\n  TIMER && debug('ran in', Date.now() - start + 'ms');\n  return tokens;\n}","map":null,"metadata":{},"sourceType":"script"}