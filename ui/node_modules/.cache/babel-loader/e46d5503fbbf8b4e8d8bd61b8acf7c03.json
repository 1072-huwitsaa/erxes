{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React, { useRef, forwardRef, useEffect } from \"react\";\nimport Portal from \"@reach/portal\";\nimport { useRect } from \"@reach/rect\";\nimport { assignRef } from \"@reach/utils\";\nimport tabbable from \"tabbable\";\nexport default forwardRef(function Popover(props, ref) {\n  return React.createElement(Portal, null, React.createElement(PopoverImpl, _extends({\n    ref: ref\n  }, props)));\n}); // Popover is conditionally rendered so we can't start measuring until it shows\n// up, so useRect needs to live down here not up in Popover\n\nvar PopoverImpl = forwardRef(function PopoverImpl(_ref, forwardedRef) {\n  var targetRef = _ref.targetRef,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? positionDefault : _ref$position,\n      style = _ref.style,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"targetRef\", \"position\", \"style\"]);\n\n  var popoverRef = useRef();\n  var popoverRect = useRect(popoverRef);\n  var targetRect = useRect(targetRef);\n  var ref = useForkedRef(popoverRef, forwardedRef);\n  useSimulateTabNavigationForReactTree(targetRef, popoverRef);\n  return React.createElement(\"div\", _extends({\n    \"data-reach-popover\": \"\",\n    ref: ref,\n    style: _extends({}, style, {\n      position: \"absolute\"\n    }, getStyles(position, targetRect, popoverRect))\n  }, rest));\n});\n\nvar getStyles = function getStyles(position, targetRect, popoverRect) {\n  var needToMeasurePopup = !popoverRect;\n\n  if (needToMeasurePopup) {\n    return {\n      visibility: \"hidden\"\n    };\n  }\n\n  return position(targetRect, popoverRect);\n};\n\nexport function positionDefault(targetRect, popoverRect) {\n  var _getCollisions = getCollisions(targetRect, popoverRect),\n      directionUp = _getCollisions.directionUp,\n      directionRight = _getCollisions.directionRight;\n\n  return {\n    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + \"px\" : targetRect.left + window.pageXOffset + \"px\",\n    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + \"px\" : targetRect.top + targetRect.height + window.pageYOffset + \"px\"\n  };\n}\nexport function positionMatchWidth(targetRect, popoverRect) {\n  var _getCollisions2 = getCollisions(targetRect, popoverRect),\n      directionUp = _getCollisions2.directionUp;\n\n  return {\n    width: targetRect.width,\n    left: targetRect.left,\n    top: directionUp ? targetRect.top - popoverRect.height + window.pageYOffset + \"px\" : targetRect.top + targetRect.height + window.pageYOffset + \"px\"\n  };\n} // Finish this another time\n// export function positionHorizontalCenter(targetRect, popoverRect) {\n//   const targetCenter = targetRect.width / 2 + targetRect.left;\n//   const popoverHalf = popoverRect.width / 2;\n//   const collisions = {\n//     right: window.innerWidth < targetCenter - popoverHalf,\n//     left: targetCenter - popoverHalf < 0\n//     // top:\n//     // bottom:\n//   };\n//   return {\n//     left: collisions.right\n//       ? `${targetRect.right - popoverRect.width + window.pageXOffset}px`\n//       : collisions.left ? `` : ``\n//   };\n// }\n\nfunction getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {\n  if (offsetLeft === void 0) {\n    offsetLeft = 0;\n  }\n\n  if (offsetBottom === void 0) {\n    offsetBottom = 0;\n  }\n\n  var collisions = {\n    top: targetRect.top - popoverRect.height < 0,\n    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,\n    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,\n    left: targetRect.left - popoverRect.width < 0\n  };\n  var directionRight = collisions.right && !collisions.left;\n  var directionUp = collisions.bottom && !collisions.top;\n  return {\n    directionRight: directionRight,\n    directionUp: directionUp\n  };\n} // Heads up, my jQuery past haunts this function. This hook scopes the tab\n// order to the React element tree, instead of the DOM tree. This way, when the\n// user navigates with tab from the targetRef, the tab order moves into the\n// popup, and then out of the popup back to the rest of the document.\n// (We call targetRef, triggerRef inside this function to avoid confusion with\n// event.target)\n\n\nfunction useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {\n  var doc = triggerRef.current.ownerDocument; // maybe in devtools\n\n  function handleKeyDown(event) {\n    if (event.key === \"Tab\" && tabbable(popoverRef.current).length === 0) {\n      return;\n    }\n\n    if (event.key === \"Tab\" && event.shiftKey) {\n      if (shiftTabbedFromElementAfterTrigger(event)) {\n        focusLastTabbableInPopover(event);\n      } else if (shiftTabbedOutOfPopover(event)) {\n        focusTriggerRef(event);\n      } else if (shiftTabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover(event);\n      }\n    } else if (event.key === \"Tab\") {\n      if (tabbedFromTriggerToPopover(event)) {\n        focusFirstPopoverTabbable(event);\n      } else if (tabbedOutOfPopover(event)) {\n        focusTabbableAfterTrigger(event);\n      } else if (tabbedToBrowserChrome(event)) {\n        disableTabbablesInPopover(event);\n      }\n    }\n  }\n\n  useEffect(function () {\n    doc.addEventListener(\"keydown\", handleKeyDown);\n    return function () {\n      return doc.removeEventListener(\"keydown\", handleKeyDown);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function getElementAfterTrigger() {\n    var elements = tabbable(doc);\n    var targetIndex = elements.indexOf(triggerRef.current);\n    return elements[targetIndex + 1];\n  }\n\n  function tabbedFromTriggerToPopover() {\n    return triggerRef.current === document.activeElement;\n  }\n\n  function focusFirstPopoverTabbable(event) {\n    var elements = tabbable(popoverRef.current);\n\n    if (elements[0]) {\n      event.preventDefault();\n      elements[0].focus();\n    }\n  }\n\n  function tabbedOutOfPopover(event) {\n    var inPopover = popoverRef.current.contains(document.activeElement);\n\n    if (inPopover) {\n      var elements = tabbable(popoverRef.current);\n      return elements[elements.length - 1] === document.activeElement;\n    }\n  }\n\n  function focusTabbableAfterTrigger(event) {\n    var elementAfterTrigger = getElementAfterTrigger();\n\n    if (elementAfterTrigger) {\n      event.preventDefault();\n      elementAfterTrigger.focus();\n    }\n  }\n\n  function shiftTabbedFromElementAfterTrigger(event) {\n    if (!event.shiftKey) return;\n    var elementAfterTrigger = getElementAfterTrigger();\n    return event.target === elementAfterTrigger;\n  }\n\n  function focusLastTabbableInPopover(event) {\n    var elements = tabbable(popoverRef.current);\n    var last = elements[elements.length - 1];\n\n    if (last) {\n      event.preventDefault();\n      last.focus();\n    }\n  }\n\n  function shiftTabbedOutOfPopover(event) {\n    var elements = tabbable(popoverRef.current);\n    return elements.length === 0 ? false : event.target === elements[0];\n  }\n\n  function focusTriggerRef(event) {\n    event.preventDefault();\n    triggerRef.current.focus();\n  }\n\n  function tabbedToBrowserChrome(event) {\n    var elements = tabbable(doc).filter(function (element) {\n      return !popoverRef.current.contains(element);\n    });\n    return event.target === elements[elements.length - 1];\n  }\n\n  function shiftTabbedToBrowserChrome(event) {\n    // we're assuming the popover will never contain the first tabbable\n    // element, and it better not, because the trigger needs to be tabbable!\n    return event.target === tabbable(doc)[0];\n  }\n\n  var restoreTabIndexTuplés = [];\n\n  function disableTabbablesInPopover() {\n    var elements = tabbable(popoverRef.current);\n    elements.forEach(function (element) {\n      restoreTabIndexTuplés.push([element, element.tabIndex]);\n      element.tabIndex = -1;\n    });\n    doc.addEventListener(\"focusin\", enableTabbablesInPopover);\n  }\n\n  function enableTabbablesInPopover(event) {\n    doc.removeEventListener(\"focusin\", enableTabbablesInPopover);\n    restoreTabIndexTuplés.forEach(function (_ref2) {\n      var element = _ref2[0],\n          tabIndex = _ref2[1];\n      element.tabIndex = tabIndex;\n    });\n  }\n} // TODO: Remove and import from @reach/utils once it's been added to the package\n\n\nfunction useForkedRef() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return React.useMemo(function () {\n    if (refs.every(function (ref) {\n      return ref == null;\n    })) {\n      return null;\n    }\n\n    return function (node) {\n      refs.forEach(function (ref) {\n        assignRef(ref, node);\n      });\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}","map":null,"metadata":{},"sourceType":"module"}