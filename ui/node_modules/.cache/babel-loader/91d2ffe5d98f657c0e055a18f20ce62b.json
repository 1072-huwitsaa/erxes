{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar lodash = require('lodash');\n\nvar d3Scale = require('d3-scale');\n\nvar React = _interopDefault(require('react'));\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar pure = _interopDefault(require('recompose/pure'));\n\nvar core = require('@nivo/core');\n\nvar d3Format = require('d3-format');\n\nvar compose = _interopDefault(require('recompose/compose'));\n\nvar withState = _interopDefault(require('recompose/withState'));\n\nvar withHandlers = _interopDefault(require('recompose/withHandlers'));\n\nvar withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));\n\nvar reactMotion = require('react-motion');\n\nvar legends = require('@nivo/legends');\n\nvar d3Shape = require('d3-shape');\n\nvar defaultProps = _interopDefault(require('recompose/defaultProps'));\n/**\n * Generates X scale.\n *\n * @param {Array.<Object>} data\n * @param {number}         width\n * @returns {Function}\n */\n\n\nvar getXScale = function getXScale(data, width) {\n  var xLengths = lodash.uniq(data.map(function (_ref) {\n    var data = _ref.data;\n    return data.length;\n  }));\n\n  if (xLengths.length > 1) {\n    throw new Error(['Found inconsitent data for x,', 'expecting all series to have same length', 'but found: ' + xLengths.join(', ')].join(' '));\n  }\n\n  return d3Scale.scalePoint().range([0, width]).domain(data[0].data.map(function (_ref2) {\n    var x = _ref2.x;\n    return x;\n  }));\n};\n/**\n * Generates Y scale for line chart.\n *\n * @param {Array.<Object>} data\n * @param {number}         height\n * @param {number|string}  minValue\n * @param {number|string}  maxValue\n * @returns {Function}\n */\n\n\nvar getYScale = function getYScale(data, height, minValue, maxValue) {\n  var minY = minValue;\n\n  if (minValue === 'auto') {\n    minY = lodash.min(data.map(function (serie) {\n      return lodash.min(serie.data.map(function (d) {\n        return d.y;\n      }));\n    }));\n  }\n\n  var maxY = maxValue;\n\n  if (maxValue === 'auto') {\n    maxY = lodash.max(data.map(function (serie) {\n      return lodash.max(serie.data.map(function (d) {\n        return d.y;\n      }));\n    }));\n  }\n\n  return d3Scale.scaleLinear().rangeRound([height, 0]).domain([minY, maxY]);\n};\n/**\n * Generates Y scale for stacked line chart.\n *\n * @param {Array.<Object>} data\n * @param {Object}         xScale\n * @param {number}         height\n * @param {number|string}  minValue\n * @param {number|string}  maxValue\n * @returns {Function}\n */\n\n\nvar getStackedYScale = function getStackedYScale(data, xScale, height, minValue, maxValue) {\n  var minY = minValue;\n\n  if (minValue === 'auto') {\n    minY = lodash.min(data.map(function (serie) {\n      return lodash.min(serie.data.map(function (d) {\n        return d.y;\n      }));\n    }));\n  }\n\n  var maxY = maxValue;\n\n  if (maxValue === 'auto') {\n    maxY = lodash.max(lodash.range(xScale.domain().length).map(function (i) {\n      return lodash.sumBy(data, function (serie) {\n        return serie.data[i].y;\n      });\n    }));\n  }\n\n  return d3Scale.scaleLinear().rangeRound([height, 0]).domain([minY, maxY]);\n};\n/**\n * Generates stacked x/y scales.\n *\n * @param {Array}         data\n * @param {number}        width\n * @param {number}        height\n * @param {number|string} minY\n * @param {number|string} maxY\n * @return {{ xScale: Function, yScale: Function }}\n */\n\n\nvar getStackedScales = function getStackedScales(_ref3) {\n  var data = _ref3.data,\n      width = _ref3.width,\n      height = _ref3.height,\n      minY = _ref3.minY,\n      maxY = _ref3.maxY;\n  var xScale = getXScale(data, width);\n  var yScale = getStackedYScale(data, xScale, height, minY, maxY);\n  return {\n    xScale: xScale,\n    yScale: yScale\n  };\n};\n/**\n * Generates non stacked x/ scales\n *\n * @param {Array}         data\n * @param {number}        width\n * @param {number}        height\n * @param {number|string} minY\n * @param {number|string} maxY\n * @return {{ xScale: Function, yScale: Function }}\n */\n\n\nvar getScales = function getScales(_ref4) {\n  var data = _ref4.data,\n      width = _ref4.width,\n      height = _ref4.height,\n      minY = _ref4.minY,\n      maxY = _ref4.maxY;\n  var xScale = getXScale(data, width);\n  var yScale = getYScale(data, height, minY, maxY);\n  return {\n    xScale: xScale,\n    yScale: yScale\n  };\n};\n/**\n * Generates x/y scales & lines for line chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       xScale\n * @param {Function}       yScale\n * @param {Function}       color\n * @return {{ xScale: Function, yScale: Function, lines: Array.<Object> }}\n */\n\n\nvar generateLines = function generateLines(data, xScale, yScale, color) {\n  return data.map(function (serie) {\n    var id = serie.id,\n        serieData = serie.data;\n    return {\n      id: id,\n      color: color(serie),\n      data: serie,\n      points: serieData.map(function (d) {\n        return Object.assign({}, d, {\n          value: d.y,\n          x: xScale(d.x),\n          y: yScale(d.y)\n        });\n      })\n    };\n  });\n};\n/**\n * Generates x/y scales & lines for stacked line chart.\n *\n * @param {Array.<Object>} data\n * @param {Function}       xScale\n * @param {Function}       yScale\n * @param {Function}       color\n * @return {{ xScale: Function, yScale: Function, lines: Array.<Object> }}\n */\n\n\nvar generateStackedLines = function generateStackedLines(data, xScale, yScale, color) {\n  return data.reduce(function (acc, serie, serieIndex) {\n    var previousPoints = serieIndex === 0 ? null : acc[serieIndex - 1].points;\n    var id = serie.id,\n        serieData = serie.data;\n    return [].concat(acc, [{\n      id: id,\n      color: color(serie),\n      data: serie,\n      points: serieData.map(function (d, i) {\n        if (!previousPoints) {\n          return Object.assign({}, d, {\n            value: d.y,\n            x: d.x,\n            y: d.y\n          });\n        }\n\n        return Object.assign({}, d, {\n          value: d.y,\n          x: d.x,\n          y: d.y + previousPoints[i].accY\n        });\n      }).map(function (d) {\n        return {\n          key: d.x,\n          value: d.value,\n          accY: d.y,\n          x: xScale(d.x),\n          y: yScale(d.y)\n        };\n      })\n    }]);\n  }, []);\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar LineAreas = function LineAreas(_ref) {\n  var areaGenerator = _ref.areaGenerator,\n      areaOpacity = _ref.areaOpacity,\n      lines = _ref.lines,\n      animate = _ref.animate,\n      motionStiffness = _ref.motionStiffness,\n      motionDamping = _ref.motionDamping;\n\n  if (animate !== true) {\n    return React.createElement('g', null, lines.slice(0).reverse().map(function (_ref2) {\n      var id = _ref2.id,\n          areaColor = _ref2.color,\n          points = _ref2.points;\n      return React.createElement('path', {\n        key: id,\n        d: areaGenerator(points),\n        fill: areaColor,\n        fillOpacity: areaOpacity,\n        strokeWidth: 0\n      });\n    }));\n  }\n\n  var springConfig = {\n    stiffness: motionStiffness,\n    damping: motionDamping\n  };\n  return React.createElement('g', null, lines.slice(0).reverse().map(function (_ref3) {\n    var id = _ref3.id,\n        areaColor = _ref3.color,\n        points = _ref3.points;\n    return React.createElement(core.SmartMotion, {\n      key: id,\n      style: function style(spring) {\n        return {\n          d: spring(areaGenerator(points), springConfig),\n          fill: spring(areaColor, springConfig)\n        };\n      }\n    }, function (style) {\n      return React.createElement('path', {\n        key: id,\n        d: style.d,\n        fill: areaColor,\n        fillOpacity: areaOpacity,\n        strokeWidth: 0\n      });\n    });\n  }));\n};\n\nLineAreas.propTypes = _extends({\n  areaOpacity: PropTypes.number.isRequired\n}, core.motionPropTypes);\nvar LineAreas$1 = pure(LineAreas);\n\nvar LineLines = function LineLines(_ref) {\n  var lines = _ref.lines,\n      lineGenerator = _ref.lineGenerator,\n      lineWidth = _ref.lineWidth,\n      animate = _ref.animate,\n      motionStiffness = _ref.motionStiffness,\n      motionDamping = _ref.motionDamping;\n\n  if (animate !== true) {\n    return React.createElement('g', null, lines.map(function (_ref2) {\n      var id = _ref2.id,\n          lineColor = _ref2.color,\n          points = _ref2.points;\n      return React.createElement('path', {\n        key: id,\n        d: lineGenerator(points),\n        fill: 'none',\n        strokeWidth: lineWidth,\n        stroke: lineColor\n      });\n    }));\n  }\n\n  var springConfig = {\n    stiffness: motionStiffness,\n    damping: motionDamping\n  };\n  return React.createElement('g', null, lines.map(function (_ref3) {\n    var id = _ref3.id,\n        lineColor = _ref3.color,\n        points = _ref3.points;\n    return React.createElement(core.SmartMotion, {\n      key: id,\n      style: function style(spring) {\n        return {\n          d: spring(lineGenerator(points), springConfig),\n          stroke: spring(lineColor, springConfig)\n        };\n      }\n    }, function (style) {\n      return React.createElement('path', {\n        key: id,\n        d: style.d,\n        fill: 'none',\n        strokeWidth: lineWidth,\n        stroke: style.stroke\n      });\n    });\n  }));\n};\n\nLineLines.propTypes = _extends({\n  lineWidth: PropTypes.number.isRequired\n}, core.motionPropTypes);\nvar LineLines$1 = pure(LineLines);\n\nvar Chip = function Chip(_ref) {\n  var color = _ref.color;\n  return React.createElement('span', {\n    style: {\n      display: 'block',\n      width: '12px',\n      height: '12px',\n      background: color\n    }\n  });\n};\n\nvar LineSlicesItem = function LineSlicesItem(_ref2) {\n  var slice = _ref2.slice,\n      height = _ref2.height,\n      showTooltip = _ref2.showTooltip,\n      hideTooltip = _ref2.hideTooltip,\n      isHover = _ref2.isHover;\n  return React.createElement('g', {\n    transform: 'translate(' + slice.x + ', 0)'\n  }, isHover && React.createElement('line', {\n    x1: 0,\n    x2: 0,\n    y1: 0,\n    y2: height,\n    stroke: '#000',\n    strokeOpacity: 0.35,\n    strokeWidth: 1\n  }), React.createElement('rect', {\n    x: -20,\n    width: 40,\n    height: height,\n    fill: '#000',\n    fillOpacity: 0,\n    onMouseEnter: showTooltip,\n    onMouseMove: showTooltip,\n    onMouseLeave: hideTooltip\n  }));\n};\n\nLineSlicesItem.propTypes = {\n  slice: PropTypes.object.isRequired,\n  height: PropTypes.number.isRequired,\n  showTooltip: PropTypes.func.isRequired,\n  hideTooltip: PropTypes.func.isRequired,\n  isHover: PropTypes.bool.isRequired,\n  theme: PropTypes.object.isRequired\n};\nvar enhance = compose(withState('isHover', 'setIsHover', false), withPropsOnChange(['slice', 'theme', 'tooltipFormat'], function (_ref3) {\n  var slice = _ref3.slice,\n      theme = _ref3.theme,\n      tooltipFormat = _ref3.tooltipFormat;\n  var format = !tooltipFormat || lodash.isFunction(tooltipFormat) ? tooltipFormat : d3Format.format(tooltipFormat);\n  var hasValues = slice.points.some(function (p) {\n    return p.value !== null;\n  });\n  return {\n    tooltip: hasValues ? React.createElement(core.TableTooltip, {\n      theme: theme,\n      rows: slice.points.filter(function (p) {\n        return p.value !== null;\n      }).map(function (p) {\n        return [React.createElement(Chip, {\n          color: p.color\n        }), p.id, format ? format(p.value) : p.value];\n      })\n    }) : null\n  };\n}), withHandlers({\n  showTooltip: function showTooltip(_ref4) {\n    var _showTooltip = _ref4.showTooltip,\n        setIsHover = _ref4.setIsHover,\n        tooltip = _ref4.tooltip;\n    return function (e) {\n      setIsHover(true);\n\n      _showTooltip(tooltip, e);\n    };\n  },\n  hideTooltip: function hideTooltip(_ref5) {\n    var _hideTooltip = _ref5.hideTooltip,\n        setIsHover = _ref5.setIsHover;\n    return function () {\n      setIsHover(false);\n\n      _hideTooltip();\n    };\n  }\n}), pure);\nvar LineSlicesItem$1 = enhance(LineSlicesItem);\n\nvar LineSlices = function LineSlices(_ref) {\n  var slices = _ref.slices,\n      height = _ref.height,\n      showTooltip = _ref.showTooltip,\n      hideTooltip = _ref.hideTooltip,\n      theme = _ref.theme,\n      tooltipFormat = _ref.tooltipFormat;\n  return React.createElement('g', null, slices.map(function (slice) {\n    return React.createElement(LineSlicesItem$1, {\n      key: slice.id,\n      slice: slice,\n      height: height,\n      showTooltip: showTooltip,\n      hideTooltip: hideTooltip,\n      theme: theme,\n      tooltipFormat: tooltipFormat\n    });\n  }));\n};\n\nLineSlices.propTypes = {\n  slices: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    x: PropTypes.number.isRequired,\n    points: PropTypes.arrayOf(PropTypes.shape({\n      id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      color: PropTypes.string.isRequired\n    })).isRequired\n  })).isRequired,\n  height: PropTypes.number.isRequired,\n  showTooltip: PropTypes.func.isRequired,\n  hideTooltip: PropTypes.func.isRequired,\n  theme: PropTypes.object.isRequired\n};\nvar LineSlices$1 = pure(LineSlices);\n\nvar LineDots = function LineDots(_ref) {\n  var lines = _ref.lines,\n      symbol = _ref.symbol,\n      size = _ref.size,\n      color = _ref.color,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor,\n      enableLabel = _ref.enableLabel,\n      label = _ref.label,\n      labelFormat = _ref.labelFormat,\n      labelYOffset = _ref.labelYOffset,\n      theme = _ref.theme,\n      animate = _ref.animate,\n      motionStiffness = _ref.motionStiffness,\n      motionDamping = _ref.motionDamping;\n  var getLabel = core.getLabelGenerator(label, labelFormat);\n  var points = lines.reduce(function (acc, line) {\n    var id = line.id,\n        points = line.points;\n    return [].concat(acc, points.filter(function (point) {\n      return point.value !== null;\n    }).map(function (point) {\n      var pointData = {\n        serie: {\n          id: id\n        },\n        x: point.key,\n        y: point.value\n      };\n      return {\n        key: id + '.' + point.x,\n        x: point.x,\n        y: point.y,\n        fill: color(line),\n        stroke: borderColor(line),\n        label: enableLabel ? getLabel(pointData) : null\n      };\n    }));\n  }, []);\n\n  if (animate !== true) {\n    return React.createElement('g', null, points.map(function (point) {\n      return React.createElement(core.DotsItem, {\n        key: point.key,\n        x: point.x,\n        y: point.y,\n        symbol: symbol,\n        size: size,\n        color: point.fill,\n        borderWidth: borderWidth,\n        borderColor: point.stroke,\n        label: point.label,\n        labelYOffset: labelYOffset,\n        theme: theme\n      });\n    }));\n  }\n\n  var springConfig = {\n    motionDamping: motionDamping,\n    motionStiffness: motionStiffness\n  };\n  return React.createElement(reactMotion.TransitionMotion, {\n    styles: points.map(function (point) {\n      return {\n        key: point.key,\n        data: point,\n        style: {\n          x: reactMotion.spring(point.x, springConfig),\n          y: reactMotion.spring(point.y, springConfig),\n          size: reactMotion.spring(size, springConfig)\n        }\n      };\n    })\n  }, function (interpolatedStyles) {\n    return React.createElement('g', null, interpolatedStyles.map(function (_ref2) {\n      var key = _ref2.key,\n          style = _ref2.style,\n          point = _ref2.data;\n      return React.createElement(core.DotsItem, _extends({\n        key: key\n      }, style, {\n        symbol: symbol,\n        color: point.fill,\n        borderWidth: borderWidth,\n        borderColor: point.stroke,\n        label: point.label,\n        labelYOffset: labelYOffset,\n        theme: theme\n      }));\n    }));\n  });\n};\n\nLineDots.propTypes = _extends({\n  lines: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string.isRequired\n  })),\n  symbol: PropTypes.func,\n  size: PropTypes.number.isRequired,\n  color: PropTypes.func.isRequired,\n  borderWidth: PropTypes.number.isRequired,\n  borderColor: PropTypes.func.isRequired,\n  // labels\n  enableLabel: PropTypes.bool.isRequired,\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n  labelFormat: PropTypes.string,\n  labelYOffset: PropTypes.number,\n  // theming\n  theme: PropTypes.shape({\n    dots: PropTypes.shape({\n      textColor: PropTypes.string.isRequired,\n      fontSize: PropTypes.string.isRequired\n    }).isRequired\n  }).isRequired\n}, core.motionPropTypes);\nLineDots.defaultProps = {\n  // labels\n  enableLabel: false,\n  label: 'y'\n};\nvar LinePropTypes = {\n  // data\n  data: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string.isRequired,\n    data: PropTypes.arrayOf(PropTypes.shape({\n      x: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n      y: PropTypes.oneOfType([PropTypes.number, PropTypes.string])\n    })).isRequired\n  })).isRequired,\n  stacked: PropTypes.bool.isRequired,\n  curve: core.lineCurvePropType.isRequired,\n  areaGenerator: PropTypes.func.isRequired,\n  lineGenerator: PropTypes.func.isRequired,\n  lines: PropTypes.array.isRequired,\n  slices: PropTypes.array.isRequired,\n  minY: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.oneOf(['auto'])]).isRequired,\n  maxY: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.oneOf(['auto'])]).isRequired,\n  xScale: PropTypes.func.isRequired,\n  // computed\n  yScale: PropTypes.func.isRequired,\n  // computed\n  // axes & grid\n  axisTop: PropTypes.object,\n  axisRight: PropTypes.object,\n  axisBottom: PropTypes.object,\n  axisLeft: PropTypes.object,\n  enableGridX: PropTypes.bool.isRequired,\n  enableGridY: PropTypes.bool.isRequired,\n  // dots\n  enableDots: PropTypes.bool.isRequired,\n  dotSymbol: PropTypes.func,\n  dotSize: PropTypes.number.isRequired,\n  dotColor: PropTypes.any.isRequired,\n  dotBorderWidth: PropTypes.number.isRequired,\n  dotBorderColor: PropTypes.any.isRequired,\n  enableDotLabel: PropTypes.bool.isRequired,\n  // markers\n  markers: PropTypes.arrayOf(PropTypes.shape({\n    axis: PropTypes.oneOf(['x', 'y']).isRequired,\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n    style: PropTypes.object\n  })),\n  // styling\n  getColor: PropTypes.func.isRequired,\n  enableArea: PropTypes.bool.isRequired,\n  areaOpacity: PropTypes.number.isRequired,\n  lineWidth: PropTypes.number.isRequired,\n  defs: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.string.isRequired\n  })).isRequired,\n  // interactivity\n  isInteractive: PropTypes.bool.isRequired,\n  enableStackTooltip: PropTypes.bool.isRequired,\n  tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  legends: PropTypes.arrayOf(PropTypes.shape(legends.LegendPropShape)).isRequired\n};\nvar LineDefaultProps = {\n  indexBy: 'id',\n  keys: ['value'],\n  stacked: false,\n  curve: 'linear',\n  // scales\n  minY: 0,\n  maxY: 'auto',\n  // axes & grid\n  axisBottom: {},\n  axisLeft: {},\n  enableGridX: true,\n  enableGridY: true,\n  // dots\n  enableDots: true,\n  dotSize: 6,\n  dotColor: 'inherit',\n  dotBorderWidth: 0,\n  dotBorderColor: 'inherit',\n  enableDotLabel: false,\n  // styling\n  colors: 'nivo',\n  colorBy: 'id',\n  enableArea: false,\n  areaOpacity: 0.2,\n  lineWidth: 2,\n  defs: [],\n  // interactivity\n  isInteractive: true,\n  enableStackTooltip: true,\n  legends: []\n};\n\nvar Line = function Line(_ref) {\n  var lines = _ref.lines,\n      lineGenerator = _ref.lineGenerator,\n      areaGenerator = _ref.areaGenerator,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      slices = _ref.slices,\n      margin = _ref.margin,\n      width = _ref.width,\n      height = _ref.height,\n      outerWidth = _ref.outerWidth,\n      outerHeight = _ref.outerHeight,\n      axisTop = _ref.axisTop,\n      axisRight = _ref.axisRight,\n      axisBottom = _ref.axisBottom,\n      axisLeft = _ref.axisLeft,\n      enableGridX = _ref.enableGridX,\n      enableGridY = _ref.enableGridY,\n      lineWidth = _ref.lineWidth,\n      enableArea = _ref.enableArea,\n      areaOpacity = _ref.areaOpacity,\n      enableDots = _ref.enableDots,\n      dotSymbol = _ref.dotSymbol,\n      dotSize = _ref.dotSize,\n      dotColor = _ref.dotColor,\n      dotBorderWidth = _ref.dotBorderWidth,\n      dotBorderColor = _ref.dotBorderColor,\n      enableDotLabel = _ref.enableDotLabel,\n      dotLabel = _ref.dotLabel,\n      dotLabelFormat = _ref.dotLabelFormat,\n      dotLabelYOffset = _ref.dotLabelYOffset,\n      markers = _ref.markers,\n      theme = _ref.theme,\n      animate = _ref.animate,\n      motionStiffness = _ref.motionStiffness,\n      motionDamping = _ref.motionDamping,\n      isInteractive = _ref.isInteractive,\n      tooltipFormat = _ref.tooltipFormat,\n      enableStackTooltip = _ref.enableStackTooltip,\n      legends$$1 = _ref.legends;\n  var motionProps = {\n    animate: animate,\n    motionDamping: motionDamping,\n    motionStiffness: motionStiffness\n  };\n  return React.createElement(core.Container, {\n    isInteractive: isInteractive,\n    theme: theme\n  }, function (_ref2) {\n    var showTooltip = _ref2.showTooltip,\n        hideTooltip = _ref2.hideTooltip;\n    return React.createElement(core.SvgWrapper, {\n      width: outerWidth,\n      height: outerHeight,\n      margin: margin\n    }, React.createElement(core.Grid, _extends({\n      theme: theme,\n      width: width,\n      height: height,\n      xScale: enableGridX ? xScale : null,\n      yScale: enableGridY ? yScale : null\n    }, motionProps)), React.createElement(core.CartesianMarkers, {\n      markers: markers,\n      width: width,\n      height: height,\n      xScale: xScale,\n      yScale: yScale,\n      theme: theme\n    }), React.createElement(core.Axes, _extends({\n      xScale: xScale,\n      yScale: yScale,\n      width: width,\n      height: height,\n      theme: theme,\n      top: axisTop,\n      right: axisRight,\n      bottom: axisBottom,\n      left: axisLeft\n    }, motionProps)), enableArea && React.createElement(LineAreas$1, _extends({\n      areaGenerator: areaGenerator,\n      areaOpacity: areaOpacity,\n      lines: lines\n    }, motionProps)), React.createElement(LineLines$1, _extends({\n      lines: lines,\n      lineGenerator: lineGenerator,\n      lineWidth: lineWidth\n    }, motionProps)), isInteractive && enableStackTooltip && React.createElement(LineSlices$1, {\n      slices: slices,\n      height: height,\n      showTooltip: showTooltip,\n      hideTooltip: hideTooltip,\n      theme: theme,\n      tooltipFormat: tooltipFormat\n    }), enableDots && React.createElement(LineDots, _extends({\n      lines: lines,\n      symbol: dotSymbol,\n      size: dotSize,\n      color: core.getInheritedColorGenerator(dotColor),\n      borderWidth: dotBorderWidth,\n      borderColor: core.getInheritedColorGenerator(dotBorderColor),\n      enableLabel: enableDotLabel,\n      label: dotLabel,\n      labelFormat: dotLabelFormat,\n      labelYOffset: dotLabelYOffset,\n      theme: theme\n    }, motionProps)), legends$$1.map(function (legend, i) {\n      var legendData = lines.map(function (line) {\n        return {\n          label: line.id,\n          fill: line.color\n        };\n      }).reverse();\n      return React.createElement(legends.BoxLegendSvg, _extends({\n        key: i\n      }, legend, {\n        containerWidth: width,\n        containerHeight: height,\n        data: legendData\n      }));\n    }));\n  });\n};\n\nLine.propTypes = LinePropTypes;\nvar enhance$1 = compose(defaultProps(LineDefaultProps), core.withTheme(), core.withColors(), core.withDimensions(), core.withMotion(), withPropsOnChange(['curve', 'height'], function (_ref3) {\n  var curve = _ref3.curve,\n      height = _ref3.height;\n  return {\n    areaGenerator: d3Shape.area().x(function (d) {\n      return d.x;\n    }).y0(height).y1(function (d) {\n      return d.y;\n    }).curve(core.curveFromProp(curve)),\n    lineGenerator: d3Shape.line().defined(function (d) {\n      return d.value !== null;\n    }).x(function (d) {\n      return d.x;\n    }).y(function (d) {\n      return d.y;\n    }).curve(core.curveFromProp(curve))\n  };\n}), withPropsOnChange(['data', 'stacked', 'width', 'height', 'minY', 'maxY'], function (_ref4) {\n  var data = _ref4.data,\n      stacked = _ref4.stacked,\n      width = _ref4.width,\n      height = _ref4.height,\n      margin = _ref4.margin,\n      minY = _ref4.minY,\n      maxY = _ref4.maxY;\n  var scales = void 0;\n  var args = {\n    data: data,\n    width: width,\n    height: height,\n    minY: minY,\n    maxY: maxY\n  };\n\n  if (stacked === true) {\n    scales = getStackedScales(args);\n  } else {\n    scales = getScales(args);\n  }\n\n  return _extends({\n    margin: margin,\n    width: width,\n    height: height\n  }, scales);\n}), withPropsOnChange(['getColor', 'xScale', 'yScale'], function (_ref5) {\n  var data = _ref5.data,\n      stacked = _ref5.stacked,\n      xScale = _ref5.xScale,\n      yScale = _ref5.yScale,\n      getColor = _ref5.getColor;\n  var lines = void 0;\n\n  if (stacked === true) {\n    lines = generateStackedLines(data, xScale, yScale, getColor);\n  } else {\n    lines = generateLines(data, xScale, yScale, getColor);\n  }\n\n  var slices = xScale.domain().map(function (id, i) {\n    var points = lodash.sortBy(lines.map(function (line) {\n      return {\n        id: line.id,\n        value: line.points[i].value,\n        y: line.points[i].y,\n        color: line.color\n      };\n    }), 'y');\n    return {\n      id: id,\n      x: xScale(id),\n      points: points\n    };\n  });\n  return {\n    lines: lines,\n    slices: slices\n  };\n}), pure);\nvar enhancedLine = enhance$1(Line);\nenhancedLine.displayName = 'enhance(Line)';\n\nvar ResponsiveLine = function ResponsiveLine(props) {\n  return React.createElement(core.ResponsiveWrapper, null, function (_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return React.createElement(enhancedLine, _extends({\n      width: width,\n      height: height\n    }, props));\n  });\n};\n\nexports.Line = enhancedLine;\nexports.ResponsiveLine = ResponsiveLine;\nexports.LinePropTypes = LinePropTypes;\nexports.LineDefaultProps = LineDefaultProps;","map":null,"metadata":{},"sourceType":"script"}