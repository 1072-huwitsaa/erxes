{"ast":null,"code":"\"use strict\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nexports.__esModule = true;\n\nvar React = require(\"react\");\n\nvar mdflavors_1 = require(\"./mdflavors\");\n\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\nfunction isObject(o) {\n  return typeof o === 'object';\n}\n\nfunction isFunction(o) {\n  return typeof o === 'function';\n}\n\nfunction get(obj, path) {\n  var spath = path.split('.');\n\n  for (var i = 0, len = spath.length; i < len; i++) {\n    if (!obj || !isObject(obj)) return undefined;\n    obj = obj[spath[i]];\n  }\n\n  return obj;\n}\n\nfunction first(o) {\n  for (var k in o) {\n    if (k != '__') return o[k];\n  }\n}\n\nfunction flatten(l) {\n  var r = [];\n  var s = '';\n\n  var flush = function flush() {\n    return s && (r.push(s), s = '');\n  };\n\n  for (var _i = 0, l_1 = l; _i < l_1.length; _i++) {\n    var i = l_1[_i];\n    if (i == null) continue;\n\n    if (isString(i)) {\n      s += i;\n    } else {\n      flush();\n      r.push(i);\n    }\n  }\n\n  flush();\n  return r.length > 1 ? r : r.length ? r[0] : null;\n}\n\nvar matcher =\n/** @class */\nfunction () {\n  function matcher(mdFlavor, inter, self) {\n    this.mdFlavor = mdFlavor;\n    this.inter = inter;\n    this.self = self;\n  }\n\n  matcher.prototype.M = function (value) {\n    if (!value) return null;\n    var m = mdflavors_1.mdMatch(this.mdFlavor, value);\n    if (!m) return value;\n    var middle = null;\n\n    switch (m.tag) {\n      case \"inter\":\n        middle = this.inter && this.inter(m.body);\n        break;\n\n      case \"self\":\n        middle = this.self && this.self(m.body);\n        break;\n\n      case \"literal\":\n        middle = m.body;\n        break;\n\n      default:\n        middle = React.createElement(m.tag, {\n          key: m.tag + m.body\n        }, this.M(m.body));\n        break;\n    }\n\n    return flatten([this.M(m.head), middle, this.M(m.tail)]);\n  };\n\n  return matcher;\n}();\n\nfunction rangeHit(node, val) {\n  for (var t in node) {\n    if (!node.hasOwnProperty(t)) continue;\n    var range = t.match(/^(-?\\d+)\\.\\.(-?\\d+)$/);\n\n    if (range && +range[1] <= val && val <= +range[2]) {\n      return node[t];\n    }\n  }\n}\n\nfunction resolveContextPath(node, p, path, context) {\n  var key = path[p];\n  var trans;\n\n  if (key != null && context[key] != null) {\n    trans = get(node, context[key].toString());\n\n    if (trans == null && +context[key] === context[key]) {\n      trans = rangeHit(node, +context[key]);\n    }\n  }\n\n  if (trans == null) trans = node._;\n  if (trans == null) trans = first(node);\n\n  if (trans != null && !isString(trans)) {\n    return resolveContextPath(trans, p + 1, path, context);\n  }\n\n  return trans;\n}\n\nfunction resolveContext(node, context) {\n  if (context == null) {\n    return resolveContextPath(node, 0, [], null);\n  } else if (!isObject(context)) {\n    return resolveContextPath(node, 0, ['_'], {\n      _: context\n    });\n  } else {\n    var ctx_keys = [];\n\n    if (node.__) {\n      ctx_keys = node.__.split('.');\n    } else {\n      for (var k in context) {\n        if (!context.hasOwnProperty(k)) continue;\n        ctx_keys.push(k);\n      }\n    }\n\n    return resolveContextPath(node, 0, ctx_keys, context);\n  }\n}\n\nvar MDText =\n/** @class */\nfunction () {\n  function MDText(texts, opt) {\n    this.texts = texts;\n    this.MDFlavor = 0; // public access is deprecated\n\n    this.notFound = undefined;\n    this.p = this.factory('p');\n    this.span = this.factory('span');\n    this.li = this.factory('li');\n    this.div = this.factory('div');\n    this.button = this.factory('button');\n    this.a = this.factory('a');\n    this.text = this.factory(null);\n    this.setOpts(opt);\n  }\n\n  MDText.prototype.setTexts = function (texts, opt) {\n    this.texts = texts;\n    this.setOpts(opt);\n  };\n\n  MDText.prototype.setOpts = function (opt) {\n    if (!opt) return;\n    if (opt.notFound !== undefined) this.notFound = opt.notFound;\n    if (opt.MDFlavor !== undefined) this.MDFlavor = opt.MDFlavor;\n  };\n\n  MDText.prototype.interpolate = function (exp, vars) {\n    var _a = exp.split(','),\n        vn = _a[0],\n        flags = _a[1];\n\n    var v = get(vars, vn);\n\n    if (v == null) {\n      return null;\n    } else if (React.isValidElement(v)) {\n      return React.cloneElement(v, {\n        key: 'r'\n      });\n    }\n\n    var vs;\n\n    if (flags && flags.match(/l/)) {\n      vs = v.toLocaleString();\n    } else {\n      vs = v.toString();\n    }\n\n    return vs;\n  };\n\n  MDText.prototype.format = function (value, vars) {\n    var _this = this;\n\n    if (!value) return value;\n    return new matcher(mdflavors_1.mdFlavors[this.MDFlavor], function (exp) {\n      return _this.interpolate(exp, vars);\n    }, function (exp) {\n      return _this.translate(exp, vars);\n    }).M(value);\n  };\n\n  MDText.prototype.translate = function (key, options) {\n    if (!key) return key;\n    var trans = get(this.texts, key);\n    var context = options && options.context;\n\n    if (trans != null && !(isString(trans) || isFunction(trans))) {\n      trans = resolveContext(trans, context);\n    }\n\n    if (trans == null) {\n      trans = options && options.notFound !== undefined ? options.notFound : this.notFound !== undefined ? this.notFound : key;\n    }\n\n    if (isFunction(trans)) {\n      trans = trans(key, context);\n    }\n\n    return this.format(trans, options);\n  };\n\n  MDText.prototype.factory = function (tagF) {\n    var _this = this; // name High Order Function for React Dev tools\n\n\n    var MDText = function MDText(props) {\n      var text = props.text,\n          tag = props.tag,\n          restProps = __rest(props, [\"text\", \"tag\"]);\n\n      var key;\n      var options;\n\n      if (text == null || isString(text)) {\n        key = text;\n        options = props;\n\n        var notFound = restProps.notFound,\n            context = restProps.context,\n            rest2Props = __rest(restProps, [\"notFound\", \"context\"]);\n\n        restProps = rest2Props;\n      } else {\n        key = text.key;\n        options = text;\n      }\n\n      var aTag = tagF || tag;\n\n      var translation = _this.translate(key, options);\n\n      return aTag ? React.createElement(aTag, restProps, translation) : translation;\n    };\n\n    return MDText;\n  };\n\n  return MDText;\n}();\n\nexports.MDText = MDText;\nvar singleton = new MDText(null);\nexports[\"default\"] = singleton;","map":null,"metadata":{},"sourceType":"script"}