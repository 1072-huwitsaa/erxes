{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nmodule.exports = function makeJuiceClient(juiceClient) {\n  juiceClient.ignoredPseudos = ['hover', 'active', 'focus', 'visited', 'link'];\n  juiceClient.widthElements = ['TABLE', 'TD', 'TH', 'IMG'];\n  juiceClient.heightElements = ['TABLE', 'TD', 'TH', 'IMG'];\n  juiceClient.tableElements = ['TABLE', 'TH', 'TR', 'TD', 'CAPTION', 'COLGROUP', 'COL', 'THEAD', 'TBODY', 'TFOOT'];\n  juiceClient.nonVisualElements = ['HEAD', 'TITLE', 'BASE', 'LINK', 'STYLE', 'META', 'SCRIPT', 'NOSCRIPT'];\n  juiceClient.styleToAttribute = {\n    'background-color': 'bgcolor',\n    'background-image': 'background',\n    'text-align': 'align',\n    'vertical-align': 'valign'\n  };\n  juiceClient.excludedProperties = [];\n  juiceClient.juiceDocument = juiceDocument;\n  juiceClient.inlineDocument = inlineDocument;\n\n  function inlineDocument($, css, options) {\n    options = options || {};\n    var rules = utils.parseCSS(css);\n    var editedElements = [];\n    var styleAttributeName = 'style';\n\n    if (options.styleAttributeName) {\n      styleAttributeName = options.styleAttributeName;\n    }\n\n    rules.forEach(handleRule);\n    editedElements.forEach(setStyleAttrs);\n\n    if (options.inlinePseudoElements) {\n      editedElements.forEach(inlinePseudoElements);\n    }\n\n    if (options.applyWidthAttributes) {\n      editedElements.forEach(function (el) {\n        setDimensionAttrs(el, 'width');\n      });\n    }\n\n    if (options.applyHeightAttributes) {\n      editedElements.forEach(function (el) {\n        setDimensionAttrs(el, 'height');\n      });\n    }\n\n    if (options.applyAttributesTableElements) {\n      editedElements.forEach(setAttributesOnTableElements);\n    }\n\n    if (options.insertPreservedExtraCss && options.extraCss) {\n      var preservedText = utils.getPreservedText(options.extraCss, {\n        mediaQueries: options.preserveMediaQueries,\n        fontFaces: options.preserveFontFaces,\n        keyFrames: options.preserveKeyFrames\n      });\n\n      if (preservedText) {\n        var $appendTo = null;\n\n        if (options.insertPreservedExtraCss !== true) {\n          $appendTo = $(options.insertPreservedExtraCss);\n        } else {\n          $appendTo = $('head');\n\n          if (!$appendTo.length) {\n            $appendTo = $('body');\n          }\n\n          if (!$appendTo.length) {\n            $appendTo = $.root();\n          }\n        }\n\n        $appendTo.first().append('<style>' + preservedText + '</style>');\n      }\n    }\n\n    function handleRule(rule) {\n      var sel = rule[0];\n      var style = rule[1];\n      var selector = new utils.Selector(sel);\n      var parsedSelector = selector.parsed();\n      var pseudoElementType = getPseudoElementType(parsedSelector); // skip rule if the selector has any pseudos which are ignored\n\n      for (var i = 0; i < parsedSelector.length; ++i) {\n        var subSel = parsedSelector[i];\n\n        if (subSel.pseudos) {\n          for (var j = 0; j < subSel.pseudos.length; ++j) {\n            var subSelPseudo = subSel.pseudos[j];\n\n            if (juiceClient.ignoredPseudos.indexOf(subSelPseudo.name) >= 0) {\n              return;\n            }\n          }\n        }\n      }\n\n      if (pseudoElementType) {\n        var last = parsedSelector[parsedSelector.length - 1];\n        var pseudos = last.pseudos;\n        last.pseudos = filterElementPseudos(last.pseudos);\n        sel = parsedSelector.toString();\n        last.pseudos = pseudos;\n      }\n\n      var els;\n\n      try {\n        els = $(sel);\n      } catch (err) {\n        // skip invalid selector\n        return;\n      }\n\n      els.each(function () {\n        var el = this;\n\n        if (el.name && juiceClient.nonVisualElements.indexOf(el.name.toUpperCase()) >= 0) {\n          return;\n        }\n\n        if (pseudoElementType) {\n          var pseudoElPropName = 'pseudo' + pseudoElementType;\n          var pseudoEl = el[pseudoElPropName];\n\n          if (!pseudoEl) {\n            pseudoEl = el[pseudoElPropName] = $('<span />').get(0);\n            pseudoEl.pseudoElementType = pseudoElementType;\n            pseudoEl.pseudoElementParent = el;\n            el[pseudoElPropName] = pseudoEl;\n          }\n\n          el = pseudoEl;\n        }\n\n        if (!el.styleProps) {\n          el.styleProps = {}; // if the element has inline styles, fake selector with topmost specificity\n\n          if ($(el).attr(styleAttributeName)) {\n            var cssText = '* { ' + $(el).attr(styleAttributeName) + ' } ';\n            addProps(utils.parseCSS(cssText)[0][1], new utils.Selector('<style>', true));\n          } // store reference to an element we need to compile style=\"\" attr for\n\n\n          editedElements.push(el);\n        } // go through the properties\n\n\n        function addProps(style, selector) {\n          for (var i = 0, l = style.length; i < l; i++) {\n            if (style[i].type == 'property') {\n              var name = style[i].name;\n              var value = style[i].value;\n              var important = style[i].value.match(/!important$/) !== null;\n              if (important && !options.preserveImportant) value = value.replace(/\\s*!important$/, ''); // adds line number and column number for the properties as \"additionalPriority\" to the\n              // properties because in CSS the position directly affect the priority.\n\n              var additionalPriority = [style[i].position.start.line, style[i].position.start.col];\n              var prop = new utils.Property(name, value, selector, important ? 2 : 0, additionalPriority);\n              var existing = el.styleProps[name]; // if property name is not in the excluded properties array\n\n              if (juiceClient.excludedProperties.indexOf(name) < 0) {\n                if (existing && existing.compare(prop) === prop || !existing) {\n                  // deleting a property let us change the order (move it to the end in the setStyleAttrs loop)\n                  if (existing && existing.selector !== selector) {\n                    delete el.styleProps[name];\n                  } else if (existing) {\n                    // make \"prop\" a special composed property.\n                    prop.nextProp = existing;\n                  }\n\n                  el.styleProps[name] = prop;\n                }\n              }\n            }\n          }\n        }\n\n        addProps(style, selector);\n      });\n    }\n\n    function setStyleAttrs(el) {\n      var l = Object.keys(el.styleProps).length;\n      var props = []; // Here we loop each property and make sure to \"expand\"\n      // linked \"nextProp\" properties happening when the same property\n      // is declared multiple times in the same selector.\n\n      Object.keys(el.styleProps).forEach(function (key) {\n        var np = el.styleProps[key];\n\n        while (typeof np !== 'undefined') {\n          props.push(np);\n          np = np.nextProp;\n        }\n      }); // sort properties by their originating selector's specificity so that\n      // props like \"padding\" and \"padding-bottom\" are resolved as expected.\n\n      props.sort(function (a, b) {\n        return a.compareFunc(b);\n      });\n      var string = props.filter(function (prop) {\n        // Content becomes the innerHTML of pseudo elements, not used as a\n        // style property\n        return prop.prop !== 'content';\n      }).map(function (prop) {\n        return prop.prop + ': ' + prop.value.replace(/[\"]/g, '\\'') + ';';\n      }).join(' ');\n\n      if (string) {\n        $(el).attr(styleAttributeName, string);\n      }\n    }\n\n    function inlinePseudoElements(el) {\n      if (el.pseudoElementType && el.styleProps.content) {\n        var parsed = parseContent(el.styleProps.content.value);\n\n        if (parsed.img) {\n          el.name = 'img';\n          $(el).attr('src', parsed.img);\n        } else {\n          $(el).text(parsed);\n        }\n\n        var parent = el.pseudoElementParent;\n\n        if (el.pseudoElementType === 'before') {\n          $(parent).prepend(el);\n        } else {\n          $(parent).append(el);\n        }\n      }\n    }\n\n    function setDimensionAttrs(el, dimension) {\n      if (!el.name) {\n        return;\n      }\n\n      var elName = el.name.toUpperCase();\n\n      if (juiceClient[dimension + 'Elements'].indexOf(elName) > -1) {\n        for (var i in el.styleProps) {\n          if (el.styleProps[i].prop === dimension) {\n            if (el.styleProps[i].value.match(/px/)) {\n              var pxSize = el.styleProps[i].value.replace('px', '');\n              $(el).attr(dimension, pxSize);\n              return;\n            }\n\n            if (juiceClient.tableElements.indexOf(elName) > -1 && el.styleProps[i].value.match(/\\%/)) {\n              $(el).attr(dimension, el.styleProps[i].value);\n              return;\n            }\n          }\n        }\n      }\n    }\n\n    function extractBackgroundUrl(value) {\n      return value.indexOf('url(') !== 0 ? value : value.replace(/^url\\(([\"'])?([^\"']+)\\1\\)$/, '$2');\n    }\n\n    function setAttributesOnTableElements(el) {\n      if (!el.name) {\n        return;\n      }\n\n      var elName = el.name.toUpperCase();\n      var styleProps = Object.keys(juiceClient.styleToAttribute);\n\n      if (juiceClient.tableElements.indexOf(elName) > -1) {\n        for (var i in el.styleProps) {\n          if (styleProps.indexOf(el.styleProps[i].prop) > -1) {\n            var prop = juiceClient.styleToAttribute[el.styleProps[i].prop];\n            var value = el.styleProps[i].value;\n\n            if (prop === 'background') {\n              value = extractBackgroundUrl(value);\n            }\n\n            if (/(linear|radial)-gradient\\(/i.test(value)) {\n              continue;\n            }\n\n            $(el).attr(prop, value);\n          }\n        }\n      }\n    }\n  }\n\n  function parseContent(content) {\n    if (content === 'none' || content === 'normal') {\n      return '';\n    }\n\n    var imageUrlMatch = content.match(/^\\s*url\\s*\\(\\s*(.*?)\\s*\\)\\s*$/i);\n\n    if (imageUrlMatch) {\n      var url = imageUrlMatch[1].replace(/^['\"]|['\"]$/g, '');\n      return {\n        img: url\n      };\n    } // Naive parsing, assume well-formed value\n\n\n    content = content.slice(1, content.length - 1); // Naive unescape, assume no unicode char codes\n\n    content = content.replace(/\\\\/g, '');\n    return content;\n  } // Return \"before\" or \"after\" if the given selector is a pseudo element (e.g.,\n  // a::after).\n\n\n  function getPseudoElementType(selector) {\n    if (selector.length === 0) {\n      return;\n    }\n\n    var pseudos = selector[selector.length - 1].pseudos;\n\n    if (!pseudos) {\n      return;\n    }\n\n    for (var i = 0; i < pseudos.length; i++) {\n      if (isPseudoElementName(pseudos[i])) {\n        return pseudos[i].name;\n      }\n    }\n  }\n\n  function isPseudoElementName(pseudo) {\n    return pseudo.name === 'before' || pseudo.name === 'after';\n  }\n\n  function filterElementPseudos(pseudos) {\n    return pseudos.filter(function (pseudo) {\n      return !isPseudoElementName(pseudo);\n    });\n  }\n\n  function juiceDocument($, options) {\n    options = utils.getDefaultOptions(options);\n    var css = extractCssFromDocument($, options);\n    css += '\\n' + options.extraCss;\n    inlineDocument($, css, options);\n    return $;\n  }\n\n  function getStylesData($, options) {\n    var results = [];\n    var stylesList = $('style');\n    var styleDataList, styleData, styleElement;\n    stylesList.each(function () {\n      styleElement = this;\n      styleDataList = styleElement.childNodes;\n\n      if (styleDataList.length !== 1) {\n        return;\n      }\n\n      styleData = styleDataList[0].data;\n\n      if (options.applyStyleTags && $(styleElement).attr('data-embed') === undefined) {\n        results.push(styleData);\n      }\n\n      if (options.removeStyleTags && $(styleElement).attr('data-embed') === undefined) {\n        var preservedText = utils.getPreservedText(styleElement.childNodes[0].nodeValue, {\n          mediaQueries: options.preserveMediaQueries,\n          fontFaces: options.preserveFontFaces,\n          keyFrames: options.preserveKeyFrames,\n          pseudos: options.preservePseudos\n        }, juiceClient.ignoredPseudos);\n\n        if (preservedText) {\n          styleElement.childNodes[0].nodeValue = preservedText;\n        } else {\n          $(styleElement).remove();\n        }\n      }\n\n      $(styleElement).removeAttr('data-embed');\n    });\n    return results;\n  }\n\n  function extractCssFromDocument($, options) {\n    var results = getStylesData($, options);\n    var css = results.join('\\n');\n    return css;\n  }\n\n  return juiceClient;\n};","map":null,"metadata":{},"sourceType":"script"}