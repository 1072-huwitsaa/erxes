{"ast":null,"code":"/*\r\nSlick Parser\r\n - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)\r\n*/\n\"use strict\"; // Notable changes from Slick.Parser 1.0.x\n// The parser now uses 2 classes: Expressions and Expression\n// `new Expressions` produces an array-like object containing a list of Expression objects\n// - Expressions::toString() produces a cleaned up expressions string\n// `new Expression` produces an array-like object\n// - Expression::toString() produces a cleaned up expression string\n// The only exposed method is parse, which produces a (cached) `new Expressions` instance\n// parsed.raw is no longer present, use .toString()\n// parsed.expression is now useless, just use the indices\n// parsed.reverse() has been removed for now, due to its apparent uselessness\n// Other changes in the Expressions object:\n// - classNames are now unique, and save both escaped and unescaped values\n// - attributes now save both escaped and unescaped values\n// - pseudos now save both escaped and unescaped values\n\nvar escapeRe = /([-.*+?^${}()|[\\]\\/\\\\])/g,\n    unescapeRe = /\\\\/g;\n\nvar escape = function escape(string) {\n  // XRegExp v2.0.0-beta-3\n  // Â« https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js\n  return (string + \"\").replace(escapeRe, '\\\\$1');\n};\n\nvar unescape = function unescape(string) {\n  return (string + \"\").replace(unescapeRe, '');\n};\n\nvar slickRe = RegExp(\n/*\r\n#!/usr/bin/env ruby\r\nputs \"\\t\\t\" + DATA.read.gsub(/\\(\\?x\\)|\\s+#.*$|\\s+|\\\\$|\\\\n/,'')\r\n__END__\r\n    \"(?x)^(?:\\\r\n      \\\\s* ( , ) \\\\s*               # Separator          \\n\\\r\n    | \\\\s* ( <combinator>+ ) \\\\s*   # Combinator         \\n\\\r\n    |      ( \\\\s+ )                 # CombinatorChildren \\n\\\r\n    |      ( <unicode>+ | \\\\* )     # Tag                \\n\\\r\n    | \\\\#  ( <unicode>+       )     # ID                 \\n\\\r\n    | \\\\.  ( <unicode>+       )     # ClassName          \\n\\\r\n    |                               # Attribute          \\n\\\r\n    \\\\[  \\\r\n        \\\\s* (<unicode1>+)  (?:  \\\r\n            \\\\s* ([*^$!~|]?=)  (?:  \\\r\n                \\\\s* (?:\\\r\n                    ([\\\"']?)(.*?)\\\\9 \\\r\n                )\\\r\n            )  \\\r\n        )?  \\\\s*  \\\r\n    \\\\](?!\\\\]) \\n\\\r\n    |   :+ ( <unicode>+ )(?:\\\r\n    \\\\( (?:\\\r\n        (?:([\\\"'])([^\\\\12]*)\\\\12)|((?:\\\\([^)]+\\\\)|[^()]*)+)\\\r\n    ) \\\\)\\\r\n    )?\\\r\n    )\"\r\n*/\n\"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\".replace(/<combinator>/, '[' + escape(\">+~`!@$%^&={}\\\\;</\") + ']').replace(/<unicode>/g, \"(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])\").replace(/<unicode1>/g, \"(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])\")); // Part\n\nvar Part = function Part(combinator) {\n  this.combinator = combinator || \" \";\n  this.tag = \"*\";\n};\n\nPart.prototype.toString = function () {\n  if (!this.raw) {\n    var xpr = \"\",\n        k,\n        part;\n    xpr += this.tag || \"*\";\n    if (this.id) xpr += \"#\" + this.id;\n    if (this.classes) xpr += \".\" + this.classList.join(\".\");\n    if (this.attributes) for (k = 0; part = this.attributes[k++];) {\n      xpr += \"[\" + part.name + (part.operator ? part.operator + '\"' + part.value + '\"' : '') + \"]\";\n    }\n    if (this.pseudos) for (k = 0; part = this.pseudos[k++];) {\n      xpr += \":\" + part.name;\n      if (part.value) xpr += \"(\" + part.value + \")\";\n    }\n    this.raw = xpr;\n  }\n\n  return this.raw;\n}; // Expression\n\n\nvar Expression = function Expression() {\n  this.length = 0;\n};\n\nExpression.prototype.toString = function () {\n  if (!this.raw) {\n    var xpr = \"\";\n\n    for (var j = 0, bit; bit = this[j++];) {\n      if (j !== 1) xpr += \" \";\n      if (bit.combinator !== \" \") xpr += bit.combinator + \" \";\n      xpr += bit;\n    }\n\n    this.raw = xpr;\n  }\n\n  return this.raw;\n};\n\nvar replacer = function replacer(rawMatch, separator, combinator, combinatorChildren, tagName, id, className, attributeKey, attributeOperator, attributeQuote, attributeValue, pseudoMarker, pseudoClass, pseudoQuote, pseudoClassQuotedValue, pseudoClassValue) {\n  var expression, current;\n\n  if (separator || !this.length) {\n    expression = this[this.length++] = new Expression();\n    if (separator) return '';\n  }\n\n  if (!expression) expression = this[this.length - 1];\n\n  if (combinator || combinatorChildren || !expression.length) {\n    current = expression[expression.length++] = new Part(combinator);\n  }\n\n  if (!current) current = expression[expression.length - 1];\n\n  if (tagName) {\n    current.tag = unescape(tagName);\n  } else if (id) {\n    current.id = unescape(id);\n  } else if (className) {\n    var unescaped = unescape(className);\n    var classes = current.classes || (current.classes = {});\n\n    if (!classes[unescaped]) {\n      classes[unescaped] = escape(className);\n      var classList = current.classList || (current.classList = []);\n      classList.push(unescaped);\n      classList.sort();\n    }\n  } else if (pseudoClass) {\n    pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\n    (current.pseudos || (current.pseudos = [])).push({\n      type: pseudoMarker.length == 1 ? 'class' : 'element',\n      name: unescape(pseudoClass),\n      escapedName: escape(pseudoClass),\n      value: pseudoClassValue ? unescape(pseudoClassValue) : null,\n      escapedValue: pseudoClassValue ? escape(pseudoClassValue) : null\n    });\n  } else if (attributeKey) {\n    attributeValue = attributeValue ? escape(attributeValue) : null;\n    (current.attributes || (current.attributes = [])).push({\n      operator: attributeOperator,\n      name: unescape(attributeKey),\n      escapedName: escape(attributeKey),\n      value: attributeValue ? unescape(attributeValue) : null,\n      escapedValue: attributeValue ? escape(attributeValue) : null\n    });\n  }\n\n  return '';\n}; // Expressions\n\n\nvar Expressions = function Expressions(expression) {\n  this.length = 0;\n  var self = this;\n  var original = expression,\n      replaced;\n\n  while (expression) {\n    replaced = expression.replace(slickRe, function () {\n      return replacer.apply(self, arguments);\n    });\n    if (replaced === expression) throw new Error(original + ' is an invalid expression');\n    expression = replaced;\n  }\n};\n\nExpressions.prototype.toString = function () {\n  if (!this.raw) {\n    var expressions = [];\n\n    for (var i = 0, expression; expression = this[i++];) {\n      expressions.push(expression);\n    }\n\n    this.raw = expressions.join(\", \");\n  }\n\n  return this.raw;\n};\n\nvar cache = {};\n\nvar parse = function parse(expression) {\n  if (expression == null) return null;\n  expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\n  return cache[expression] || (cache[expression] = new Expressions(expression));\n};\n\nmodule.exports = parse;","map":null,"metadata":{},"sourceType":"script"}